<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>KLS Research Blog</title>
		<description>Nothing to see here...</description>
		<link>http://vision.sista.arizona.edu/ksimek/research</link>
		<atom:link href="http://vision.sista.arizona.edu/ksimek/research/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>Work Log</title>
				<description>

&lt;div class=&quot;meta-info&quot;&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;Project&lt;/th&gt;
        &lt;td&gt;&lt;a href=&quot;/ksimek/research/projects/tulips.html&quot;&gt;Tulips&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Subproject&lt;/th&gt;
        &lt;td&gt;Data Association v3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Working path&lt;/th&gt;
        &lt;td&gt;projects/&amp;#8203;tulips/&amp;#8203;trunk/&amp;#8203;src/&amp;#8203;matlab/&amp;#8203;data_association_3&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
        &lt;th&gt;SVN Revision&lt;/th&gt;
        &lt;td&gt;15229&lt;/td&gt;
    &lt;/tr&gt;


&lt;/table&gt;

    Unless otherwise noted, all filesystem paths are relative to the &quot;Working path&quot; named above.
&lt;/div&gt;


&lt;h2&gt;Updating data structures to Version 2&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;* Refactored several variable names, some functions may need updating.
* Corrs was changed from cell-of-structs to a cell-array.  Some functions may still need updating.
* Removed old, unused variables
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Thinking on sampling&lt;/h2&gt;

&lt;p&gt;Did a writeup on MCMCDA with attachments, see associated &quot;strategy&quot; entry&lt;/p&gt;

&lt;h2&gt;Thinking on priors&lt;/h2&gt;

&lt;p&gt;Did a writeup on association priors, see associated &quot;reference&quot; entry&lt;/p&gt;
</description>
				<pubDate>Mon, 23 Sep 2013 00:00:00 -0700</pubDate>
				<link>http://vision.sista.arizona.edu/ksimek/research/2013/09/23/work-log</link>
				<guid isPermaLink="true">http://vision.sista.arizona.edu/ksimek/research/2013/09/23/work-log</guid>
			</item>
		
			<item>
				<title>Split/Merge moves and Association Priors</title>
				<description>&lt;p&gt;Thinking again about split/merge moves, and the problem of the exploding number of split moves as the nubmer of observations increases.&lt;/p&gt;

&lt;p&gt;Part of the problem is the fact that we're treating all associations as equal under the prior.  This has the side-effect that the prior strongly prefers more curves in a model as opposed to fewer.  Consider a scenario with N observations, and M curves.  There are M&lt;sup&gt;N&lt;/sup&gt; number of ways to assign these observations to M curves.  Compare this with a model with one curve -- there's only one possible assigment.  Since all assignments are equal under the prior, the model with M curves is more favored by the prior by a factor of M&lt;sup&gt;N.&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;For this reason, I propose that a more sensible prior is one that is uniform over the number of curves in the scene.  Then, given the number of curves, the prior over associations is uniform.  In other words, given an association, it's prior should be 1/M&lt;sup&gt;N,&lt;/sup&gt; where M is the number of curves represented in the association.&lt;/p&gt;

&lt;p&gt;When running a split move, the number of ways to split is 2&lt;sup&gt;K,&lt;/sup&gt; where K is the number of observations associated with the original curve.  If chosen uniformly, the Metropolis-Hastings proposal probability is 2&lt;sup&gt;K.&lt;/sup&gt;  This should cancel nicely with the prior term in the MH acceptance ratio.&lt;/p&gt;
</description>
				<pubDate>Mon, 23 Sep 2013 00:00:00 -0700</pubDate>
				<link>http://vision.sista.arizona.edu/ksimek/research/2013/09/23/splitmerge-moves-and-association-priors</link>
				<guid isPermaLink="true">http://vision.sista.arizona.edu/ksimek/research/2013/09/23/splitmerge-moves-and-association-priors</guid>
			</item>
		
			<item>
				<title>MCMCDA Sampling with Attachment</title>
				<description>&lt;p&gt;The old MCMCDA gibbs sampler runs into trouble now that we allow attachment.&lt;/p&gt;

&lt;p&gt;Previously, for any observation, we would compute the ML of grouping it with each candidate, and select a candidate from those weights.&lt;/p&gt;

&lt;p&gt;The problem now is that regrouping an observation sometimes causes it's old group to vanish, and the question of what to do with the group's children is unanswered.  The same problem occurs if a regrouping makes a curve shorter, and children were attached to the now-missing structure.&lt;/p&gt;

&lt;h2&gt;Metropolis Hastings&lt;/h2&gt;

&lt;p&gt;Things become much easier if we move away from Gibbs sampling.  Gibbs was nice for a proof of concept, because we never failed to pick embarrassingly good candidates, and we almost always moved toward a better result with each step.  However, it was very expensive, and now we have a question of how to compute the ML of a candidate whose attachment property is unknown.&lt;/p&gt;

&lt;p&gt;So, we'll move to Metropolis Hastings.  We resolve the attachment issue by using a simple rule:  every time a track's association changes, we re-sample its the attachment and the attachment of its former children.&lt;/p&gt;

&lt;h2&gt;Sampling Associations.&lt;/h2&gt;

&lt;p&gt;When sampling associations, we'll use two types of moves:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;swap&lt;/strong&gt;: re-assign a single observation&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;split/merge&lt;/strong&gt; re-assign a group of observations&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The swap move will be similar to the existing Gibbs move, except we'll choose from candidates uniformly at random.  Split/merge proposals will be naive; we'll incorporate an association prior to counter the exploding number of split moves.&lt;/p&gt;

&lt;h2&gt;Re-sampling attachment&lt;/h2&gt;

&lt;p&gt;After sampling a new association, we'll re-sample attachment.  For this, we'll introduce a new function &lt;code&gt;sample_attachment&lt;/code&gt;, which will be responsible for constructing a list of reasonable candidates and attachment parameters (Start point and branch position), and selecting one at random (probably based on geometry, i.e. not uniform).  It returns the sampled attachment, along with the proposal probability.  It can optionally receive a &lt;code&gt;hint&lt;/code&gt; parameter, which is a list of attachment candidates, along with a guess as to the attachment parameters.  The candidate of &quot;no attachment&quot; should always be an option.&lt;/p&gt;

&lt;p&gt;We'll also need a function that returns the probabiliy of selecting a specific attachment, according to &lt;code&gt;sample_attachment&lt;/code&gt;, for computing the reverse move.&lt;/p&gt;

&lt;h2&gt;Topology moves&lt;/h2&gt;

&lt;p&gt;In addition to association moves, we'll also have topology moves.  This will consist of simply calling &lt;code&gt;sample_attachment&lt;/code&gt; without a sampling an association beforehand.&lt;/p&gt;
</description>
				<pubDate>Mon, 23 Sep 2013 00:00:00 -0700</pubDate>
				<link>http://vision.sista.arizona.edu/ksimek/research/2013/09/23/mcmcda-sampling-with-attachment</link>
				<guid isPermaLink="true">http://vision.sista.arizona.edu/ksimek/research/2013/09/23/mcmcda-sampling-with-attachment</guid>
			</item>
		
			<item>
				<title>Branching ML Done</title>
				<description>

&lt;div class=&quot;meta-info&quot;&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;Project&lt;/th&gt;
        &lt;td&gt;&lt;a href=&quot;/ksimek/research/projects/tulips.html&quot;&gt;Tulips&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Subproject&lt;/th&gt;
        &lt;td&gt;Data Association v3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Working path&lt;/th&gt;
        &lt;td&gt;projects/&amp;#8203;tulips/&amp;#8203;trunk/&amp;#8203;src/&amp;#8203;matlab/&amp;#8203;data_association_3&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
        &lt;th&gt;SVN Revision&lt;/th&gt;
        &lt;td&gt;15229&lt;/td&gt;
    &lt;/tr&gt;


&lt;/table&gt;

    Unless otherwise noted, all filesystem paths are relative to the &quot;Working path&quot; named above.
&lt;/div&gt;


&lt;p&gt;Finally finished implementing and confirming the multi-view branching ML.  Next steps:&lt;/p&gt;

&lt;p&gt;Quick&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;re-run tests with non-zero start index&lt;/li&gt;
&lt;li&gt;test three-levels of branching

&lt;ul&gt;
&lt;li&gt;reconstruction&lt;/li&gt;
&lt;li&gt;ML vs. reference&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;cleanup Corr fields

&lt;ul&gt;
&lt;li&gt;eliminate clean_ fields&lt;/li&gt;
&lt;li&gt;group fields by processing stage&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;map-out processing pipeline&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Medium&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;finish ground-truthing (Friday night, Saturday)&lt;/li&gt;
&lt;li&gt;implement recursive update&lt;/li&gt;
&lt;li&gt;code for inferring branching parameters.&lt;/li&gt;
&lt;li&gt;Finish training

&lt;ul&gt;
&lt;li&gt;infer branching parameters&lt;/li&gt;
&lt;li&gt;re-write training ML&lt;/li&gt;
&lt;li&gt;re-train prior parameters with full ML

&lt;ul&gt;
&lt;li&gt;jointly train FG and BG using same&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;gibbs sampler&lt;/li&gt;
&lt;li&gt;evaluation code&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Reach&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;split-merge moves&lt;/li&gt;
&lt;/ul&gt;

</description>
				<pubDate>Fri, 20 Sep 2013 00:00:00 -0700</pubDate>
				<link>http://vision.sista.arizona.edu/ksimek/research/2013/09/20/branching-ml-done</link>
				<guid isPermaLink="true">http://vision.sista.arizona.edu/ksimek/research/2013/09/20/branching-ml-done</guid>
			</item>
		
			<item>
				<title>refactoring; dependencies</title>
				<description>

&lt;div class=&quot;meta-info&quot;&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;Project&lt;/th&gt;
        &lt;td&gt;&lt;a href=&quot;/ksimek/research/projects/tulips.html&quot;&gt;Tulips&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Subproject&lt;/th&gt;
        &lt;td&gt;Data Association v3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Working path&lt;/th&gt;
        &lt;td&gt;projects/&amp;#8203;tulips/&amp;#8203;trunk/&amp;#8203;src/&amp;#8203;matlab/&amp;#8203;data_association_3&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
        &lt;th&gt;SVN Revision&lt;/th&gt;
        &lt;td&gt;15229&lt;/td&gt;
    &lt;/tr&gt;


&lt;/table&gt;

    Unless otherwise noted, all filesystem paths are relative to the &quot;Working path&quot; named above.
&lt;/div&gt;


&lt;h1&gt;TODO&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;investigate difference between ML implementations&lt;/li&gt;
&lt;li&gt;handle nonzero start-index in branching. re-run confirmation&lt;/li&gt;
&lt;li&gt;ground truth - trace datasets 7 through 10&lt;/li&gt;
&lt;li&gt;retrain using attachment&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Invstigating consistent ML implementations&lt;/h1&gt;

&lt;p&gt;Discovered issue:  was calling &lt;code&gt;curve_tree_ml&lt;/code&gt; instead of &lt;code&gt;curve_tree_ml_2&lt;/code&gt;.  Working now&lt;/p&gt;

&lt;h2&gt;Aside: common mistakeis&lt;/h2&gt;

&lt;p&gt;Losing a too much time to stupid organizational mistakes --&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;indexing,&lt;/li&gt;
&lt;li&gt;passing wrong copies of variables to code,&lt;/li&gt;
&lt;li&gt;leaving random debugging code in miscellaneous functions,&lt;/li&gt;
&lt;li&gt;running wrong debugging branch in code,&lt;/li&gt;
&lt;li&gt;running wrong version of function.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Code has gotten complex enough that managing all of these little sharp edges is too expensive.  Need to start being more disciplined.  Solutions&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;indexing&lt;/strong&gt;: use functions for common indexing tasks

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;one_d_to_three_d&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;to_block_index&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;miscellaneous variables&lt;/strong&gt;: clean-up workspace every evening&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Debugging cruft&lt;/strong&gt;:

&lt;ul&gt;
&lt;li&gt;if code is an in-line test, refactor questionable code into functions; write a real test.&lt;/li&gt;
&lt;li&gt;if code is a &lt;code&gt;plot&lt;/code&gt;, &lt;code&gt;imagesc&lt;/code&gt;, or &lt;code&gt;printf&lt;/code&gt;, always wrap in a DEBUGGING block, even if its a two-minute test.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Wrong debugging branch&lt;/strong&gt;:

&lt;ul&gt;
&lt;li&gt;if using &lt;code&gt;method = 1&lt;/code&gt; give names like &lt;code&gt;method = MARKOV&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;display warnings for non-standard methods.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;wrong version of function&lt;/strong&gt;: depends on future of old code

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;deprecation&lt;/strong&gt;: add block to old reference code: &lt;code&gt;fprintf('running legacy code (press enter)'); pause;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;reference implementation&lt;/strong&gt;: rename to *_ref.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Discussion: start_index and branch_index&lt;/h1&gt;

&lt;p&gt;In previous days, I was torn over whether I should add start_index to branch_index before evaluating.&lt;/p&gt;

&lt;p&gt;The answer is yes, because it greatly simplifies the optimization of start_index, because you don't have to re-adjust the children's branch_indices.&lt;/p&gt;

&lt;p&gt;how is markov blanket determined (pre or post offset indexing?)&lt;/p&gt;

&lt;p&gt;Do we need to recurse after attach?&lt;/p&gt;

&lt;p&gt;RAW VALUES should be stored, not derived values.  branch_index is a raw value.&lt;/p&gt;

&lt;p&gt;*Example: * C is attached to B.  We want to attach B to A, with start index of 10.  Assume branch_index is stored relative to the zero-index (as opposed to the first observed point).  After attaching, we need to update C's branch point; if we later detach B from A, B's branch point need to be updated again.  There's potential for drift to accumulate after all of these upates.&lt;/p&gt;

&lt;p&gt;To avoid confusion, replace branch_index to branch_distance; will convert to an index value before computing. Also &lt;code&gt;prior_indices&lt;/code&gt; needs updating?  Or just eliminate&lt;/p&gt;

&lt;h2&gt;recursive Updating after attachment&lt;/h2&gt;

&lt;p&gt;Consider attachment:&lt;/p&gt;

&lt;p&gt;Before&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(D -&amp;gt; C -&amp;gt; B)    (A)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(D -&amp;gt; C -&amp;gt; B -&amp;gt; A) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Visually,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;             A   B C D         A B C D 
             |   | | |         | | | |
             |   | |/          | | |/
             |   | +           | | +  
             |   |/            | |/ 
             |   +       ==&amp;gt;   | +
             |                 |/         
             |                 +      
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;After attaching B to A,

&lt;ul&gt;
&lt;li&gt;C's branch index changes, so...

&lt;ul&gt;
&lt;li&gt;C's branch distribution changes, so...

&lt;ul&gt;
&lt;li&gt;D's branch distribution changes so...

&lt;ul&gt;
&lt;li&gt;D's ML changes&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C's ML changes.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C's prior_K doesnt change.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;As far as stored fields go, it looks like branch distributions change recursively after attachment, etc.&lt;/p&gt;

&lt;h1&gt;Dependencies&lt;/h1&gt;

&lt;p&gt;Did some thinking about dependencies; what needs to be updated when parents are changed.  Scan of the notes are available below.  Also did &lt;a href=&quot;/ksimek/research/reference/2013/09/19/dependencies/&quot;&gt;a reference writeup&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/ksimek/research/img/2013-09-19-dependency_notes.jpg&quot;&gt;Dependency hand-written notes&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;Refactoring&lt;/h1&gt;

&lt;p&gt;Changed &lt;code&gt;Corr.branch_index&lt;/code&gt; to &lt;code&gt;Corr.branch_distance&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Replaced all instances of &lt;code&gt;Corrs(i).branch_index&lt;/code&gt; with &lt;code&gt;get_branch_index(Corrs, i)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Replaced Corr.ll_indices* with Corr.ll_distances.&lt;/p&gt;

&lt;p&gt;removed Corr.prior_indices&lt;/p&gt;

&lt;p&gt;TODO: replace kernel(XX,YY) with eval_kernel(asdf)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;see att_set_start_index_2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TODO: replace Corrs cell array with Corrs structure array&lt;/p&gt;

&lt;h1&gt;TODO&lt;/h1&gt;

&lt;p&gt;Minor&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;re-run tests with non-zero start index&lt;/li&gt;
&lt;li&gt;test three-levels of branching

&lt;ul&gt;
&lt;li&gt;reconstruction&lt;/li&gt;
&lt;li&gt;ML vs. reference&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;cleanup Corr fields

&lt;ul&gt;
&lt;li&gt;eliminate clean_ fields&lt;/li&gt;
&lt;li&gt;group fields by processing stage&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;map-out processing pipeline&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Medium&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;finish ground-truthing (Friday night, Saturday)&lt;/li&gt;
&lt;li&gt;implement recursive update&lt;/li&gt;
&lt;li&gt;code for inferring branching parameters.&lt;/li&gt;
&lt;li&gt;Finish training

&lt;ul&gt;
&lt;li&gt;infer branching parameters&lt;/li&gt;
&lt;li&gt;re-write training ML&lt;/li&gt;
&lt;li&gt;re-train prior parameters with full ML&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MCMCDA sampler&lt;/li&gt;
&lt;/ul&gt;

</description>
				<pubDate>Thu, 19 Sep 2013 00:00:00 -0700</pubDate>
				<link>http://vision.sista.arizona.edu/ksimek/research/2013/09/19/work-log</link>
				<guid isPermaLink="true">http://vision.sista.arizona.edu/ksimek/research/2013/09/19/work-log</guid>
			</item>
		
			<item>
				<title>Summary of Dependency relationships</title>
				<description>

&lt;div class=&quot;meta-info&quot;&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;Project&lt;/th&gt;
        &lt;td&gt;&lt;a href=&quot;/ksimek/research/projects/tulips.html&quot;&gt;Tulips&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Subproject&lt;/th&gt;
        &lt;td&gt;Data Association v3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Working path&lt;/th&gt;
        &lt;td&gt;projects/&amp;#8203;tulips/&amp;#8203;trunk/&amp;#8203;src/&amp;#8203;matlab/&amp;#8203;data_association_3&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
        &lt;th&gt;SVN Revision&lt;/th&gt;
        &lt;td&gt;15229&lt;/td&gt;
    &lt;/tr&gt;


&lt;/table&gt;

    Unless otherwise noted, all filesystem paths are relative to the &quot;Working path&quot; named above.
&lt;/div&gt;


&lt;p&gt;The dependency between individual variables is a bit complicated, but if we group variables together, the relationship between the groups is simple.  We group parameters into &quot;self&quot; parameters and &quot;inherited&quot; parameters.&lt;/p&gt;

&lt;p&gt;Self parameters are immune to changes to parents or children.
Inherited parameters are affected by any changes to parent.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SELF PARAMETERS

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;reconstruction fields&lt;/em&gt;: assoc, corr, ll_*,&lt;/li&gt;
&lt;li&gt;start index&lt;/li&gt;
&lt;li&gt;prior_K&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;INHERITED PARAMETERS

&lt;ul&gt;
&lt;li&gt;branch distance, branch_index&lt;/li&gt;
&lt;li&gt;&lt;em&gt;branch distribution&lt;/em&gt;:  mu_b, mu_Sigma, branch_mu, branch_Sigma&lt;/li&gt;
&lt;li&gt;Marginal likelihood.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This can be summarized as follows:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Any time a curve is changed in any way, we must recursively update all inherited parameters.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This &quot;if anything changes, update everything&quot; rule is a bit broad, and we can use a finer-grained definition to update fewer inherited fields, but in general, we only avoid updating fields that are inexpensive to update anyway.  For heavy-wieght fields (e.g. branch distribution and ML), they are affected by everything, so we're forced to update them after every change.  Thus, the simpler rule is only nominally less efficeint, and much easier to implement and understand.&lt;/p&gt;
</description>
				<pubDate>Thu, 19 Sep 2013 00:00:00 -0700</pubDate>
				<link>http://vision.sista.arizona.edu/ksimek/research/2013/09/19/dependencies</link>
				<guid isPermaLink="true">http://vision.sista.arizona.edu/ksimek/research/2013/09/19/dependencies</guid>
			</item>
		
			<item>
				<title>Testing full-tree covariance matrix</title>
				<description>

&lt;div class=&quot;meta-info&quot;&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;Project&lt;/th&gt;
        &lt;td&gt;&lt;a href=&quot;/ksimek/research/projects/tulips.html&quot;&gt;Tulips&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Subproject&lt;/th&gt;
        &lt;td&gt;Data Association v3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Working path&lt;/th&gt;
        &lt;td&gt;projects/&amp;#8203;tulips/&amp;#8203;trunk/&amp;#8203;src/&amp;#8203;matlab/&amp;#8203;data_association_3&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
        &lt;th&gt;SVN Revision&lt;/th&gt;
        &lt;td&gt;15229&lt;/td&gt;
    &lt;/tr&gt;


&lt;/table&gt;

    Unless otherwise noted, all filesystem paths are relative to the &quot;Working path&quot; named above.
&lt;/div&gt;


&lt;p&gt;Running covariance confirmation for model_type = 3.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Results don't match.&lt;/p&gt;

&lt;p&gt;Off-diagonals are okay.&lt;/p&gt;

&lt;p&gt;on-diagonal's are larger in reference impl; on order of 10.&lt;/p&gt;

&lt;p&gt;Reference implementation has all positive eigenvalues.  Likely bug is in testing implementation.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Open question: Does branch_index need to be incremented by start_index?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;also, is prior_K including start_index?&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Root curve is block incorrect, which means we can focus on either &lt;code&gt;build_root_object&lt;/code&gt; or &lt;code&gt;build_sibling block&lt;/code&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Got it&lt;/strong&gt;: prior_K was computed with model_type = 1.  It contains no perturb covariance.  But root block does contain perturb covariance.&lt;/p&gt;

&lt;p&gt;Re-attach using:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wacv_Corrs_ratt = wacv_Corrs;
for i = 1:numel(wacv_Corrs_reatt)
    C = wacv_Corrs_reatt{i};
    wacv_Corrs_reatt = attach_2(wacv_Corrs_reatt, i, C.parent_ci, C.start_index, C.branch_index,params);
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now results are identical for the testing set&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;results differ on the full set.&lt;/p&gt;

&lt;p&gt;in testing set, all branches occured from the zero point on the parent.  the full set has branches from other points, and we're getting different results.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Found the cause of the problem: it was leftover cruft code I added during debugging.  Caused non-symmetric matrix.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;TODO: Move &quot;confirm full covariance against reference implementation&quot; into its own test folder&lt;/p&gt;

&lt;p&gt;TODO: handle nonzero start-index in branching. re-run confirmation&lt;/p&gt;

&lt;p&gt;TODO: finish &quot;confirm curve-tree ML against reference implementation&quot;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Struggling with curve_ml5, where Chol is failing.  Looks like the problem is in att_Set_Branch_index; branch conditional covariance is not positive definite.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Found: indexing bug in &lt;code&gt;attachment/attach_2.m&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Comparing three methods:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% method 1
ml1 = curve_tree_ml_ref(wacv_Corrs_reatt, params, data_)
% method 2
ml2 = curve_tree_ml(wacv_Corrs_reatt, params, data_)
% method 3
ml3 = 0;
for i = 1:numel(wacv_Corrs_reatt)
    ml = ml + curve_ml5( ...
            wacv_Corrs_reatt{i}, ...
            data_, ...
            params, ...
            get_model_kernel(params, params.model_type), ...
            params.ml_block_size, ...
            params.ml_markov_order);
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All three currently differ significantly.&lt;/p&gt;

&lt;p&gt;Also compared against an indendent model, whose ML was about 300 points lower.&lt;/p&gt;

&lt;p&gt;At this point, method 2 and method 3 should be giving the same results, but aren't.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Moved covariance matrix test to &lt;code&gt;test/test_construct_attachment_covariance.m&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Re-ran and now it's failing :-/&lt;/p&gt;

&lt;p&gt;Modified it to save the output; re-running to debug.&lt;/p&gt;

&lt;p&gt;Needed to re-run &lt;code&gt;attach_2()&lt;/code&gt;, because prior_K was stale&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;TODO:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;troubleshoot covariance test&lt;/li&gt;
&lt;li&gt;investigate difference between method 2 and method 3 above.&lt;/li&gt;
&lt;li&gt;handle nonzero start-index in branching. re-run confirmation&lt;/li&gt;
&lt;li&gt;ground truth - trace datasets 7 through 10&lt;/li&gt;
&lt;li&gt;retrain using attachment&lt;/li&gt;
&lt;/ul&gt;

</description>
				<pubDate>Wed, 18 Sep 2013 00:00:00 -0700</pubDate>
				<link>http://vision.sista.arizona.edu/ksimek/research/2013/09/18/work-log</link>
				<guid isPermaLink="true">http://vision.sista.arizona.edu/ksimek/research/2013/09/18/work-log</guid>
			</item>
		
			<item>
				<title>Building reference implementation of full-tree covariance</title>
				<description>

&lt;div class=&quot;meta-info&quot;&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;Project&lt;/th&gt;
        &lt;td&gt;&lt;a href=&quot;/ksimek/research/projects/tulips.html&quot;&gt;Tulips&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Subproject&lt;/th&gt;
        &lt;td&gt;Data Association v3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Working path&lt;/th&gt;
        &lt;td&gt;projects/&amp;#8203;tulips/&amp;#8203;trunk/&amp;#8203;src/&amp;#8203;matlab/&amp;#8203;data_association_3&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
        &lt;th&gt;SVN Revision&lt;/th&gt;
        &lt;td&gt;15229&lt;/td&gt;
    &lt;/tr&gt;


&lt;/table&gt;

    Unless otherwise noted, all filesystem paths are relative to the &quot;Working path&quot; named above.
&lt;/div&gt;




&lt;div&gt;
Building reference version of `build_attachment_covariance()`.  It does full recursion for every element, taking \(O(n^2 \log n)\) time.
&lt;/div&gt;


&lt;hr /&gt;

&lt;p&gt;Running now with model_type = 1;  estimated runtime: 45 minutes.  (compare this to less than 5 seconds in the fast version).&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Results don't match.&lt;/p&gt;

&lt;p&gt;Issue 1: topology indices array was reversed; handled inheritance wrongly.
Issue 2: forgot about start_index; should add to all curve indices.&lt;/p&gt;

&lt;p&gt;Results now match when model type = 1.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Matching results suggest that the covariance matrix is correctly implemented as designed, but why are we getting negative eigenvalues?&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Next: re-run with model_type = 3.&lt;/p&gt;
</description>
				<pubDate>Tue, 17 Sep 2013 00:00:00 -0700</pubDate>
				<link>http://vision.sista.arizona.edu/ksimek/research/2013/09/17/work-log</link>
				<guid isPermaLink="true">http://vision.sista.arizona.edu/ksimek/research/2013/09/17/work-log</guid>
			</item>
		
			<item>
				<title>Full-tree covariance; Run on WACV dataset</title>
				<description>

&lt;div class=&quot;meta-info&quot;&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;Project&lt;/th&gt;
        &lt;td&gt;&lt;a href=&quot;/ksimek/research/projects/tulips.html&quot;&gt;Tulips&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Subproject&lt;/th&gt;
        &lt;td&gt;Data Association v3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Working path&lt;/th&gt;
        &lt;td&gt;projects/&amp;#8203;tulips/&amp;#8203;trunk/&amp;#8203;src/&amp;#8203;matlab/&amp;#8203;data_association_3&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
        &lt;th&gt;SVN Revision&lt;/th&gt;
        &lt;td&gt;15229&lt;/td&gt;
    &lt;/tr&gt;


&lt;/table&gt;

    Unless otherwise noted, all filesystem paths are relative to the &quot;Working path&quot; named above.
&lt;/div&gt;


&lt;p&gt;Finished testing &lt;code&gt;construct_attachment_covariance.m&lt;/code&gt; against legacy method for constructing covariance matrix.  Constructed new test &lt;code&gt;wacv_2014/run_wacv_2.m&lt;/code&gt; to compare new method against old method in &lt;code&gt;wacv_2014/run_wacv.m&lt;/code&gt;.  After significant amount of debugging, results match.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tweak to Corr.prior_K: &lt;/strong&gt; don't replicate until needed.  New function &lt;code&gt;tools/one_d_to_trhee_d&lt;/code&gt; helps with this.&lt;/p&gt;

&lt;p&gt;Now, to test new covariance matrix algorithm against the existing branching ML code to confirm that the latter is correct...&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Wrote &lt;code&gt;curve_tree_ml_ref&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Having trouble running  on wacv dataset.  The covariance matrix constructed by &lt;code&gt;construct_attachment_covariance&lt;/code&gt; has several &lt;em&gt;negative eigenvalues&lt;/em&gt; (magnitude on the order of 1000).  These don't appear when attachments don't exist.&lt;/p&gt;

&lt;p&gt;Old method of constructing the covariance matrix has several negative eigenvalues, but they're on the order of 1e-9.  (were'nt they identical?)&lt;/p&gt;

&lt;p&gt;Lets go back to the WACV example and run everything on those...&lt;/p&gt;

&lt;p&gt;The big question to answer is: &lt;strong&gt;is WACV ML better with attachments or worse?&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;On second look, the test and reference prior matricies &lt;strong&gt;don't&lt;/strong&gt; match.  Going back to debugging &lt;code&gt;construct_attachment_covaraince.m&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;found bug in bugfix in attach.m.   results now match&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Now covariancaes from wacv and curve_tree_ml_ref don't match.  Furthermore, curve_tree_ml_ref crashes because the matrix isn't positive definite.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Found issue: wacv program forced model_type to be 1 (no-perturb model).  This accounts for the difference between wacv reconstruction and the reference ML code.&lt;/p&gt;

&lt;p&gt;Still don't know why we're getting negative eigenvalues when model_type != 1.&lt;/p&gt;

&lt;h2&gt;Medium-term planning&lt;/h2&gt;

&lt;p&gt;Q: What is needed to get end-to-end running?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Efficient ML for branching model.&lt;/li&gt;
&lt;li&gt;inference of branch points, given attachment (part of proposal mechanism?)&lt;/li&gt;
&lt;li&gt;training with attachment

&lt;ul&gt;
&lt;li&gt;updated training ML&lt;/li&gt;
&lt;li&gt;updated training procedure&lt;/li&gt;
&lt;li&gt;joint training of foreground and background, with shared noise parameter&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;re-write sampling infrastructure

&lt;ul&gt;
&lt;li&gt;pair candidates&lt;/li&gt;
&lt;li&gt;gibbs moves&lt;/li&gt;
&lt;li&gt;merge/split (using Swendsen Wang?)&lt;/li&gt;
&lt;li&gt;attach/detach&lt;/li&gt;
&lt;li&gt;HACKS

&lt;ul&gt;
&lt;li&gt;background subtraction?&lt;/li&gt;
&lt;li&gt;&quot;cheating&quot; (nonreversible) merge/split&lt;/li&gt;
&lt;li&gt;forced attachment?&lt;/li&gt;
&lt;li&gt;heuristic initialization?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;TODO&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Finish debugging reference ML: &lt;code&gt;curve_tree_ml_ref.m&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;why are we getting negative eigenvalues in prior matrix when model_type &gt; 1?&lt;/li&gt;
&lt;li&gt;compare against long-hand version of matrix (slow, full recursive version).  Does it still have negative eigenvalues?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Confirm that WACV dataset has better ML when attachments are modeled.&lt;/li&gt;
&lt;/ul&gt;

</description>
				<pubDate>Mon, 16 Sep 2013 00:00:00 -0700</pubDate>
				<link>http://vision.sista.arizona.edu/ksimek/research/2013/09/16/work-log</link>
				<guid isPermaLink="true">http://vision.sista.arizona.edu/ksimek/research/2013/09/16/work-log</guid>
			</item>
		
			<item>
				<title>Branching prior covariance; implementing</title>
				<description>

&lt;div class=&quot;meta-info&quot;&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;Project&lt;/th&gt;
        &lt;td&gt;&lt;a href=&quot;/ksimek/research/projects/tulips.html&quot;&gt;Tulips&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Subproject&lt;/th&gt;
        &lt;td&gt;Data Association v3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Working path&lt;/th&gt;
        &lt;td&gt;projects/&amp;#8203;tulips/&amp;#8203;trunk/&amp;#8203;src/&amp;#8203;matlab/&amp;#8203;data_association_3&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
        &lt;th&gt;SVN Revision&lt;/th&gt;
        &lt;td&gt;15229&lt;/td&gt;
    &lt;/tr&gt;


&lt;/table&gt;

    Unless otherwise noted, all filesystem paths are relative to the &quot;Working path&quot; named above.
&lt;/div&gt;


&lt;p&gt;Goals:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ground truth - trace datasets 7 through 10&lt;/li&gt;
&lt;li&gt;build new attachment covariance&lt;/li&gt;
&lt;li&gt;reconstruct ground truth using new attachment covariance&lt;/li&gt;
&lt;li&gt;work attachment covariance function into ml&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Building Full Attachment Covariance Matrix&lt;/h2&gt;

&lt;p&gt;See &lt;code&gt;attachment/construct_attachment_covariance.m&lt;/code&gt; (filename still in flux).&lt;/p&gt;

&lt;p&gt;Issue: The recursive definition of the attached curve kernel that we outlined yesterday is too expensive to implement naively.  Can implement by re-using precomputed values, but the branch point isn't necessarilly one of the observed points, so it's not necesarilly represented in the curve's &lt;code&gt;prior_K&lt;/code&gt;.  This means we need to construct covariance entries between each of the attachment points and their parent and child curves.  Then we can run the &quot;memoized&quot; recursive function.&lt;/p&gt;

&lt;h2&gt;Base self covariance&lt;/h2&gt;

&lt;p&gt;Key idea: each child curve has a &quot;base self covariance&quot; that is extra covariance inherited from the branch point on parent that is added to all points of the curve self-covariance matrix.  That curve, in turn, has a base covariance, that &lt;em&gt;it&lt;/em&gt; inherits, all the way to the root, whose base covariance is the &quot;position variance&quot; parameter.  Thus, the leaves have a base covariance that is the sum of all the incremental variance of all the branches to the root.&lt;/p&gt;

&lt;p&gt;The base covariance is an NxN matrix, where N is the number of views.  We construct each in isolation, and then cumulatively sum them from root to leaf.&lt;/p&gt;

&lt;p&gt;Every element of the curve's observed-point covariance matrix is increased by the base_covariance relative to it's entry; e.g. if element (k_{ij}) is the covariance between a point in view 3 and a point in view 5, you'll add the (3,5) element of the base covariance matrix.&lt;/p&gt;

&lt;h2&gt;Base Parent covariance&lt;/h2&gt;

&lt;p&gt;Each child curve also hase a &quot;parent covariance&quot; (for lack of a better term), which is the set of covariances between the branch point and each of the parent points.  Again, this is inherited recursively; just as the curve's covariance has it's self-covariance added, the parent covariance has the paren'ts self-covariance added.&lt;/p&gt;

&lt;p&gt;This will be used for the off-diagonal blocks of the full attachment covariance matrix.&lt;/p&gt;

&lt;h2&gt;Implementation Misc&lt;/h2&gt;

&lt;p&gt;Issues during implementation and testing of &lt;code&gt;construct_attachment_covariance&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;replacing Cell-of-structs with struct-array:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Corrs = cell2mat(Corrs);
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;The trivial code path of calling &lt;code&gt;blkdiag&lt;/code&gt; takes 500ms. Wow!&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Running on the WACV dataset is giving bad results.&lt;/p&gt;

&lt;p&gt;Looks like the covariance matrix is different from the one in the reference implementation.&lt;/p&gt;

&lt;p&gt;TODO:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Need to convert from &quot;index of branch index&quot; to simply &quot;branch index&quot;.&lt;/li&gt;
&lt;li&gt;More debugging.&lt;/li&gt;
&lt;/ul&gt;

</description>
				<pubDate>Thu, 12 Sep 2013 00:00:00 -0700</pubDate>
				<link>http://vision.sista.arizona.edu/ksimek/research/2013/09/12/work-log</link>
				<guid isPermaLink="true">http://vision.sista.arizona.edu/ksimek/research/2013/09/12/work-log</guid>
			</item>
		
	</channel>
</rss>
