<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>KLS Research Blog</title>
		<description>Nothing to see here...</description>
		<link>http://vision.sista.arizona.edu/ksimek/research</link>
		<atom:link href="http://vision.sista.arizona.edu/ksimek/research/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>Branching ML Done</title>
				<description>

&lt;div class=&quot;meta-info&quot;&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;Project&lt;/th&gt;
        &lt;td&gt;&lt;a href=&quot;/ksimek/research/projects/tulips.html&quot;&gt;Tulips&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Subproject&lt;/th&gt;
        &lt;td&gt;Data Association v3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Working path&lt;/th&gt;
        &lt;td&gt;projects/&amp;#8203;tulips/&amp;#8203;trunk/&amp;#8203;src/&amp;#8203;matlab/&amp;#8203;data_association_3&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
        &lt;th&gt;SVN Revision&lt;/th&gt;
        &lt;td&gt;15229&lt;/td&gt;
    &lt;/tr&gt;


&lt;/table&gt;

    Unless otherwise noted, all filesystem paths are relative to the &quot;Working path&quot; named above.
&lt;/div&gt;


&lt;p&gt;Finally finished implementing and confirming the multi-view branching ML.  Next steps:&lt;/p&gt;

&lt;p&gt;Quick&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;re-run tests with non-zero start index&lt;/li&gt;
&lt;li&gt;test three-levels of branching

&lt;ul&gt;
&lt;li&gt;reconstruction&lt;/li&gt;
&lt;li&gt;ML vs. reference&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;cleanup Corr fields

&lt;ul&gt;
&lt;li&gt;eliminate clean_ fields&lt;/li&gt;
&lt;li&gt;group fields by processing stage&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;map-out processing pipeline&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Medium&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;finish ground-truthing (Friday night, Saturday)&lt;/li&gt;
&lt;li&gt;implement recursive update&lt;/li&gt;
&lt;li&gt;code for inferring branching parameters.&lt;/li&gt;
&lt;li&gt;Finish training

&lt;ul&gt;
&lt;li&gt;infer branching parameters&lt;/li&gt;
&lt;li&gt;re-write training ML&lt;/li&gt;
&lt;li&gt;re-train prior parameters with full ML

&lt;ul&gt;
&lt;li&gt;jointly train FG and BG using same&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;gibbs sampler&lt;/li&gt;
&lt;li&gt;evaluation code&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Reach&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;split-merge moves&lt;/li&gt;
&lt;/ul&gt;

</description>
				<pubDate>Fri, 20 Sep 2013 00:00:00 -0700</pubDate>
				<link>http://vision.sista.arizona.edu/ksimek/research/2013/09/20/branching-ml-done</link>
				<guid isPermaLink="true">http://vision.sista.arizona.edu/ksimek/research/2013/09/20/branching-ml-done</guid>
			</item>
		
			<item>
				<title>refactoring; dependencies</title>
				<description>

&lt;div class=&quot;meta-info&quot;&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;Project&lt;/th&gt;
        &lt;td&gt;&lt;a href=&quot;/ksimek/research/projects/tulips.html&quot;&gt;Tulips&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Subproject&lt;/th&gt;
        &lt;td&gt;Data Association v3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Working path&lt;/th&gt;
        &lt;td&gt;projects/&amp;#8203;tulips/&amp;#8203;trunk/&amp;#8203;src/&amp;#8203;matlab/&amp;#8203;data_association_3&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
        &lt;th&gt;SVN Revision&lt;/th&gt;
        &lt;td&gt;15229&lt;/td&gt;
    &lt;/tr&gt;


&lt;/table&gt;

    Unless otherwise noted, all filesystem paths are relative to the &quot;Working path&quot; named above.
&lt;/div&gt;


&lt;h1&gt;TODO&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;investigate difference between ML implementations&lt;/li&gt;
&lt;li&gt;handle nonzero start-index in branching. re-run confirmation&lt;/li&gt;
&lt;li&gt;ground truth - trace datasets 7 through 10&lt;/li&gt;
&lt;li&gt;retrain using attachment&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Invstigating consistent ML implementations&lt;/h1&gt;

&lt;p&gt;Discovered issue:  was calling &lt;code&gt;curve_tree_ml&lt;/code&gt; instead of &lt;code&gt;curve_tree_ml_2&lt;/code&gt;.  Working now&lt;/p&gt;

&lt;h2&gt;Aside: common mistakeis&lt;/h2&gt;

&lt;p&gt;Losing a too much time to stupid organizational mistakes --&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;indexing,&lt;/li&gt;
&lt;li&gt;passing wrong copies of variables to code,&lt;/li&gt;
&lt;li&gt;leaving random debugging code in miscellaneous functions,&lt;/li&gt;
&lt;li&gt;running wrong debugging branch in code,&lt;/li&gt;
&lt;li&gt;running wrong version of function.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Code has gotten complex enough that managing all of these little sharp edges is too expensive.  Need to start being more disciplined.  Solutions&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;indexing&lt;/strong&gt;: use functions for common indexing tasks

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;one_d_to_three_d&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;to_block_index&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;miscellaneous variables&lt;/strong&gt;: clean-up workspace every evening&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Debugging cruft&lt;/strong&gt;:

&lt;ul&gt;
&lt;li&gt;if code is an in-line test, refactor questionable code into functions; write a real test.&lt;/li&gt;
&lt;li&gt;if code is a &lt;code&gt;plot&lt;/code&gt;, &lt;code&gt;imagesc&lt;/code&gt;, or &lt;code&gt;printf&lt;/code&gt;, always wrap in a DEBUGGING block, even if its a two-minute test.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Wrong debugging branch&lt;/strong&gt;:

&lt;ul&gt;
&lt;li&gt;if using &lt;code&gt;method = 1&lt;/code&gt; give names like &lt;code&gt;method = MARKOV&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;display warnings for non-standard methods.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;wrong version of function&lt;/strong&gt;: depends on future of old code

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;deprecation&lt;/strong&gt;: add block to old reference code: &lt;code&gt;fprintf('running legacy code (press enter)'); pause;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;reference implementation&lt;/strong&gt;: rename to *_ref.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Discussion: start_index and branch_index&lt;/h1&gt;

&lt;p&gt;In previous days, I was torn over whether I should add start_index to branch_index before evaluating.&lt;/p&gt;

&lt;p&gt;The answer is yes, because it greatly simplifies the optimization of start_index, because you don't have to re-adjust the children's branch_indices.&lt;/p&gt;

&lt;p&gt;how is markov blanket determined (pre or post offset indexing?)&lt;/p&gt;

&lt;p&gt;Do we need to recurse after attach?&lt;/p&gt;

&lt;p&gt;RAW VALUES should be stored, not derived values.  branch_index is a raw value.&lt;/p&gt;

&lt;p&gt;*Example: * C is attached to B.  We want to attach B to A, with start index of 10.  Assume branch_index is stored relative to the zero-index (as opposed to the first observed point).  After attaching, we need to update C's branch point; if we later detach B from A, B's branch point need to be updated again.  There's potential for drift to accumulate after all of these upates.&lt;/p&gt;

&lt;p&gt;To avoid confusion, replace branch_index to branch_distance; will convert to an index value before computing. Also &lt;code&gt;prior_indices&lt;/code&gt; needs updating?  Or just eliminate&lt;/p&gt;

&lt;h2&gt;recursive Updating after attachment&lt;/h2&gt;

&lt;p&gt;Consider attachment:&lt;/p&gt;

&lt;p&gt;Before&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(D -&amp;gt; C -&amp;gt; B)    (A)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(D -&amp;gt; C -&amp;gt; B -&amp;gt; A) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Visually,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;             A   B C D         A B C D 
             |   | | |         | | | |
             |   | |/          | | |/
             |   | +           | | +  
             |   |/            | |/ 
             |   +       ==&amp;gt;   | +
             |                 |/         
             |                 +      
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;After attaching B to A,

&lt;ul&gt;
&lt;li&gt;C's branch index changes, so...

&lt;ul&gt;
&lt;li&gt;C's branch distribution changes, so...

&lt;ul&gt;
&lt;li&gt;D's branch distribution changes so...

&lt;ul&gt;
&lt;li&gt;D's ML changes&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C's ML changes.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C's prior_K doesnt change.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;As far as stored fields go, it looks like branch distributions change recursively after attachment, etc.&lt;/p&gt;

&lt;h1&gt;Dependencies&lt;/h1&gt;

&lt;p&gt;Did some thinking about dependencies; what needs to be updated when parents are changed.  Scan of the notes are available below.  Also did &lt;a href=&quot;/ksimek/research/reference/2013/09/19/dependencies/&quot;&gt;a reference writeup&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/ksimek/research/img/2013-09-19-dependency_notes.jpg&quot;&gt;Dependency hand-written notes&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;Refactoring&lt;/h1&gt;

&lt;p&gt;Changed &lt;code&gt;Corr.branch_index&lt;/code&gt; to &lt;code&gt;Corr.branch_distance&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Replaced all instances of &lt;code&gt;Corrs(i).branch_index&lt;/code&gt; with &lt;code&gt;get_branch_index(Corrs, i)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Replaced Corr.ll_indices* with Corr.ll_distances.&lt;/p&gt;

&lt;p&gt;removed Corr.prior_indices&lt;/p&gt;

&lt;p&gt;TODO: replace kernel(XX,YY) with eval_kernel(asdf)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;see att_set_start_index_2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TODO: replace Corrs cell array with Corrs structure array&lt;/p&gt;

&lt;h1&gt;TODO&lt;/h1&gt;

&lt;p&gt;Minor&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;re-run tests with non-zero start index&lt;/li&gt;
&lt;li&gt;test three-levels of branching

&lt;ul&gt;
&lt;li&gt;reconstruction&lt;/li&gt;
&lt;li&gt;ML vs. reference&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;cleanup Corr fields

&lt;ul&gt;
&lt;li&gt;eliminate clean_ fields&lt;/li&gt;
&lt;li&gt;group fields by processing stage&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;map-out processing pipeline&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Medium&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;finish ground-truthing (Friday night, Saturday)&lt;/li&gt;
&lt;li&gt;implement recursive update&lt;/li&gt;
&lt;li&gt;code for inferring branching parameters.&lt;/li&gt;
&lt;li&gt;Finish training

&lt;ul&gt;
&lt;li&gt;infer branching parameters&lt;/li&gt;
&lt;li&gt;re-write training ML&lt;/li&gt;
&lt;li&gt;re-train prior parameters with full ML&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MCMCDA sampler&lt;/li&gt;
&lt;/ul&gt;

</description>
				<pubDate>Thu, 19 Sep 2013 00:00:00 -0700</pubDate>
				<link>http://vision.sista.arizona.edu/ksimek/research/2013/09/19/work-log</link>
				<guid isPermaLink="true">http://vision.sista.arizona.edu/ksimek/research/2013/09/19/work-log</guid>
			</item>
		
			<item>
				<title>Summary of Dependency relationships</title>
				<description>

&lt;div class=&quot;meta-info&quot;&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;Project&lt;/th&gt;
        &lt;td&gt;&lt;a href=&quot;/ksimek/research/projects/tulips.html&quot;&gt;Tulips&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Subproject&lt;/th&gt;
        &lt;td&gt;Data Association v3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Working path&lt;/th&gt;
        &lt;td&gt;projects/&amp;#8203;tulips/&amp;#8203;trunk/&amp;#8203;src/&amp;#8203;matlab/&amp;#8203;data_association_3&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
        &lt;th&gt;SVN Revision&lt;/th&gt;
        &lt;td&gt;15229&lt;/td&gt;
    &lt;/tr&gt;


&lt;/table&gt;

    Unless otherwise noted, all filesystem paths are relative to the &quot;Working path&quot; named above.
&lt;/div&gt;


&lt;p&gt;The dependency between individual variables is a bit complicated, but if we group variables together, the relationship between the groups is simple.  We group parameters into &quot;self&quot; parameters and &quot;inherited&quot; parameters.&lt;/p&gt;

&lt;p&gt;Self parameters are immune to changes to parents or children.
Inherited parameters are affected by any changes to parent.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SELF PARAMETERS

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;reconstruction fields&lt;/em&gt;: assoc, corr, ll_*,&lt;/li&gt;
&lt;li&gt;start index&lt;/li&gt;
&lt;li&gt;prior_K&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;INHERITED PARAMETERS

&lt;ul&gt;
&lt;li&gt;branch distance, branch_index&lt;/li&gt;
&lt;li&gt;&lt;em&gt;branch distribution&lt;/em&gt;:  mu_b, mu_Sigma, branch_mu, branch_Sigma&lt;/li&gt;
&lt;li&gt;Marginal likelihood.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This can be summarized as follows:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Any time a curve is changed in any way, we must recursively update all inherited parameters.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This &quot;if anything changes, update everything&quot; rule is a bit broad, and we can use a finer-grained definition to update fewer inherited fields, but in general, we only avoid updating fields that are inexpensive to update anyway.  For heavy-wieght fields (e.g. branch distribution and ML), they are affected by everything, so we're forced to update them after every change.  Thus, the simpler rule is only nominally less efficeint, and much easier to implement and understand.&lt;/p&gt;
</description>
				<pubDate>Thu, 19 Sep 2013 00:00:00 -0700</pubDate>
				<link>http://vision.sista.arizona.edu/ksimek/research/2013/09/19/dependencies</link>
				<guid isPermaLink="true">http://vision.sista.arizona.edu/ksimek/research/2013/09/19/dependencies</guid>
			</item>
		
			<item>
				<title>Testing full-tree covariance matrix</title>
				<description>

&lt;div class=&quot;meta-info&quot;&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;Project&lt;/th&gt;
        &lt;td&gt;&lt;a href=&quot;/ksimek/research/projects/tulips.html&quot;&gt;Tulips&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Subproject&lt;/th&gt;
        &lt;td&gt;Data Association v3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Working path&lt;/th&gt;
        &lt;td&gt;projects/&amp;#8203;tulips/&amp;#8203;trunk/&amp;#8203;src/&amp;#8203;matlab/&amp;#8203;data_association_3&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
        &lt;th&gt;SVN Revision&lt;/th&gt;
        &lt;td&gt;15229&lt;/td&gt;
    &lt;/tr&gt;


&lt;/table&gt;

    Unless otherwise noted, all filesystem paths are relative to the &quot;Working path&quot; named above.
&lt;/div&gt;


&lt;p&gt;Running covariance confirmation for model_type = 3.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Results don't match.&lt;/p&gt;

&lt;p&gt;Off-diagonals are okay.&lt;/p&gt;

&lt;p&gt;on-diagonal's are larger in reference impl; on order of 10.&lt;/p&gt;

&lt;p&gt;Reference implementation has all positive eigenvalues.  Likely bug is in testing implementation.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Open question: Does branch_index need to be incremented by start_index?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;also, is prior_K including start_index?&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Root curve is block incorrect, which means we can focus on either &lt;code&gt;build_root_object&lt;/code&gt; or &lt;code&gt;build_sibling block&lt;/code&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Got it&lt;/strong&gt;: prior_K was computed with model_type = 1.  It contains no perturb covariance.  But root block does contain perturb covariance.&lt;/p&gt;

&lt;p&gt;Re-attach using:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wacv_Corrs_ratt = wacv_Corrs;
for i = 1:numel(wacv_Corrs_reatt)
    C = wacv_Corrs_reatt{i};
    wacv_Corrs_reatt = attach_2(wacv_Corrs_reatt, i, C.parent_ci, C.start_index, C.branch_index,params);
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now results are identical for the testing set&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;results differ on the full set.&lt;/p&gt;

&lt;p&gt;in testing set, all branches occured from the zero point on the parent.  the full set has branches from other points, and we're getting different results.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Found the cause of the problem: it was leftover cruft code I added during debugging.  Caused non-symmetric matrix.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;TODO: Move &quot;confirm full covariance against reference implementation&quot; into its own test folder&lt;/p&gt;

&lt;p&gt;TODO: handle nonzero start-index in branching. re-run confirmation&lt;/p&gt;

&lt;p&gt;TODO: finish &quot;confirm curve-tree ML against reference implementation&quot;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Struggling with curve_ml5, where Chol is failing.  Looks like the problem is in att_Set_Branch_index; branch conditional covariance is not positive definite.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Found: indexing bug in &lt;code&gt;attachment/attach_2.m&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Comparing three methods:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% method 1
ml1 = curve_tree_ml_ref(wacv_Corrs_reatt, params, data_)
% method 2
ml2 = curve_tree_ml(wacv_Corrs_reatt, params, data_)
% method 3
ml3 = 0;
for i = 1:numel(wacv_Corrs_reatt)
    ml = ml + curve_ml5( ...
            wacv_Corrs_reatt{i}, ...
            data_, ...
            params, ...
            get_model_kernel(params, params.model_type), ...
            params.ml_block_size, ...
            params.ml_markov_order);
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All three currently differ significantly.&lt;/p&gt;

&lt;p&gt;Also compared against an indendent model, whose ML was about 300 points lower.&lt;/p&gt;

&lt;p&gt;At this point, method 2 and method 3 should be giving the same results, but aren't.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Moved covariance matrix test to &lt;code&gt;test/test_construct_attachment_covariance.m&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Re-ran and now it's failing :-/&lt;/p&gt;

&lt;p&gt;Modified it to save the output; re-running to debug.&lt;/p&gt;

&lt;p&gt;Needed to re-run &lt;code&gt;attach_2()&lt;/code&gt;, because prior_K was stale&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;TODO:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;troubleshoot covariance test&lt;/li&gt;
&lt;li&gt;investigate difference between method 2 and method 3 above.&lt;/li&gt;
&lt;li&gt;handle nonzero start-index in branching. re-run confirmation&lt;/li&gt;
&lt;li&gt;ground truth - trace datasets 7 through 10&lt;/li&gt;
&lt;li&gt;retrain using attachment&lt;/li&gt;
&lt;/ul&gt;

</description>
				<pubDate>Wed, 18 Sep 2013 00:00:00 -0700</pubDate>
				<link>http://vision.sista.arizona.edu/ksimek/research/2013/09/18/work-log</link>
				<guid isPermaLink="true">http://vision.sista.arizona.edu/ksimek/research/2013/09/18/work-log</guid>
			</item>
		
			<item>
				<title>Building reference implementation of full-tree covariance</title>
				<description>

&lt;div class=&quot;meta-info&quot;&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;Project&lt;/th&gt;
        &lt;td&gt;&lt;a href=&quot;/ksimek/research/projects/tulips.html&quot;&gt;Tulips&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Subproject&lt;/th&gt;
        &lt;td&gt;Data Association v3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Working path&lt;/th&gt;
        &lt;td&gt;projects/&amp;#8203;tulips/&amp;#8203;trunk/&amp;#8203;src/&amp;#8203;matlab/&amp;#8203;data_association_3&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
        &lt;th&gt;SVN Revision&lt;/th&gt;
        &lt;td&gt;15229&lt;/td&gt;
    &lt;/tr&gt;


&lt;/table&gt;

    Unless otherwise noted, all filesystem paths are relative to the &quot;Working path&quot; named above.
&lt;/div&gt;




&lt;div&gt;
Building reference version of `build_attachment_covariance()`.  It does full recursion for every element, taking \(O(n^2 \log n)\) time.
&lt;/div&gt;


&lt;hr /&gt;

&lt;p&gt;Running now with model_type = 1;  estimated runtime: 45 minutes.  (compare this to less than 5 seconds in the fast version).&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Results don't match.&lt;/p&gt;

&lt;p&gt;Issue 1: topology indices array was reversed; handled inheritance wrongly.
Issue 2: forgot about start_index; should add to all curve indices.&lt;/p&gt;

&lt;p&gt;Results now match when model type = 1.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Matching results suggest that the covariance matrix is correctly implemented as designed, but why are we getting negative eigenvalues?&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Next: re-run with model_type = 3.&lt;/p&gt;
</description>
				<pubDate>Tue, 17 Sep 2013 00:00:00 -0700</pubDate>
				<link>http://vision.sista.arizona.edu/ksimek/research/2013/09/17/work-log</link>
				<guid isPermaLink="true">http://vision.sista.arizona.edu/ksimek/research/2013/09/17/work-log</guid>
			</item>
		
			<item>
				<title>Full-tree covariance; Run on WACV dataset</title>
				<description>

&lt;div class=&quot;meta-info&quot;&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;Project&lt;/th&gt;
        &lt;td&gt;&lt;a href=&quot;/ksimek/research/projects/tulips.html&quot;&gt;Tulips&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Subproject&lt;/th&gt;
        &lt;td&gt;Data Association v3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Working path&lt;/th&gt;
        &lt;td&gt;projects/&amp;#8203;tulips/&amp;#8203;trunk/&amp;#8203;src/&amp;#8203;matlab/&amp;#8203;data_association_3&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
        &lt;th&gt;SVN Revision&lt;/th&gt;
        &lt;td&gt;15229&lt;/td&gt;
    &lt;/tr&gt;


&lt;/table&gt;

    Unless otherwise noted, all filesystem paths are relative to the &quot;Working path&quot; named above.
&lt;/div&gt;


&lt;p&gt;Finished testing &lt;code&gt;construct_attachment_covariance.m&lt;/code&gt; against legacy method for constructing covariance matrix.  Constructed new test &lt;code&gt;wacv_2014/run_wacv_2.m&lt;/code&gt; to compare new method against old method in &lt;code&gt;wacv_2014/run_wacv.m&lt;/code&gt;.  After significant amount of debugging, results match.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tweak to Corr.prior_K: &lt;/strong&gt; don't replicate until needed.  New function &lt;code&gt;tools/one_d_to_trhee_d&lt;/code&gt; helps with this.&lt;/p&gt;

&lt;p&gt;Now, to test new covariance matrix algorithm against the existing branching ML code to confirm that the latter is correct...&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Wrote &lt;code&gt;curve_tree_ml_ref&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Having trouble running  on wacv dataset.  The covariance matrix constructed by &lt;code&gt;construct_attachment_covariance&lt;/code&gt; has several &lt;em&gt;negative eigenvalues&lt;/em&gt; (magnitude on the order of 1000).  These don't appear when attachments don't exist.&lt;/p&gt;

&lt;p&gt;Old method of constructing the covariance matrix has several negative eigenvalues, but they're on the order of 1e-9.  (were'nt they identical?)&lt;/p&gt;

&lt;p&gt;Lets go back to the WACV example and run everything on those...&lt;/p&gt;

&lt;p&gt;The big question to answer is: &lt;strong&gt;is WACV ML better with attachments or worse?&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;On second look, the test and reference prior matricies &lt;strong&gt;don't&lt;/strong&gt; match.  Going back to debugging &lt;code&gt;construct_attachment_covaraince.m&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;found bug in bugfix in attach.m.   results now match&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Now covariancaes from wacv and curve_tree_ml_ref don't match.  Furthermore, curve_tree_ml_ref crashes because the matrix isn't positive definite.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Found issue: wacv program forced model_type to be 1 (no-perturb model).  This accounts for the difference between wacv reconstruction and the reference ML code.&lt;/p&gt;

&lt;p&gt;Still don't know why we're getting negative eigenvalues when model_type != 1.&lt;/p&gt;

&lt;h2&gt;Medium-term planning&lt;/h2&gt;

&lt;p&gt;Q: What is needed to get end-to-end running?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Efficient ML for branching model.&lt;/li&gt;
&lt;li&gt;inference of branch points, given attachment (part of proposal mechanism?)&lt;/li&gt;
&lt;li&gt;training with attachment

&lt;ul&gt;
&lt;li&gt;updated training ML&lt;/li&gt;
&lt;li&gt;updated training procedure&lt;/li&gt;
&lt;li&gt;joint training of foreground and background, with shared noise parameter&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;re-write sampling infrastructure

&lt;ul&gt;
&lt;li&gt;pair candidates&lt;/li&gt;
&lt;li&gt;gibbs moves&lt;/li&gt;
&lt;li&gt;merge/split (using Swendsen Wang?)&lt;/li&gt;
&lt;li&gt;attach/detach&lt;/li&gt;
&lt;li&gt;HACKS

&lt;ul&gt;
&lt;li&gt;background subtraction?&lt;/li&gt;
&lt;li&gt;&quot;cheating&quot; (nonreversible) merge/split&lt;/li&gt;
&lt;li&gt;forced attachment?&lt;/li&gt;
&lt;li&gt;heuristic initialization?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;TODO&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Finish debugging reference ML: &lt;code&gt;curve_tree_ml_ref.m&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;why are we getting negative eigenvalues in prior matrix when model_type &gt; 1?&lt;/li&gt;
&lt;li&gt;compare against long-hand version of matrix (slow, full recursive version).  Does it still have negative eigenvalues?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Confirm that WACV dataset has better ML when attachments are modeled.&lt;/li&gt;
&lt;/ul&gt;

</description>
				<pubDate>Mon, 16 Sep 2013 00:00:00 -0700</pubDate>
				<link>http://vision.sista.arizona.edu/ksimek/research/2013/09/16/work-log</link>
				<guid isPermaLink="true">http://vision.sista.arizona.edu/ksimek/research/2013/09/16/work-log</guid>
			</item>
		
			<item>
				<title>Branching prior covariance; implementing</title>
				<description>

&lt;div class=&quot;meta-info&quot;&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;Project&lt;/th&gt;
        &lt;td&gt;&lt;a href=&quot;/ksimek/research/projects/tulips.html&quot;&gt;Tulips&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Subproject&lt;/th&gt;
        &lt;td&gt;Data Association v3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Working path&lt;/th&gt;
        &lt;td&gt;projects/&amp;#8203;tulips/&amp;#8203;trunk/&amp;#8203;src/&amp;#8203;matlab/&amp;#8203;data_association_3&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
        &lt;th&gt;SVN Revision&lt;/th&gt;
        &lt;td&gt;15229&lt;/td&gt;
    &lt;/tr&gt;


&lt;/table&gt;

    Unless otherwise noted, all filesystem paths are relative to the &quot;Working path&quot; named above.
&lt;/div&gt;


&lt;p&gt;Goals:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ground truth - trace datasets 7 through 10&lt;/li&gt;
&lt;li&gt;build new attachment covariance&lt;/li&gt;
&lt;li&gt;reconstruct ground truth using new attachment covariance&lt;/li&gt;
&lt;li&gt;work attachment covariance function into ml&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Building Full Attachment Covariance Matrix&lt;/h2&gt;

&lt;p&gt;See &lt;code&gt;attachment/construct_attachment_covariance.m&lt;/code&gt; (filename still in flux).&lt;/p&gt;

&lt;p&gt;Issue: The recursive definition of the attached curve kernel that we outlined yesterday is too expensive to implement naively.  Can implement by re-using precomputed values, but the branch point isn't necessarilly one of the observed points, so it's not necesarilly represented in the curve's &lt;code&gt;prior_K&lt;/code&gt;.  This means we need to construct covariance entries between each of the attachment points and their parent and child curves.  Then we can run the &quot;memoized&quot; recursive function.&lt;/p&gt;

&lt;h2&gt;Base self covariance&lt;/h2&gt;

&lt;p&gt;Key idea: each child curve has a &quot;base self covariance&quot; that is extra covariance inherited from the branch point on parent that is added to all points of the curve self-covariance matrix.  That curve, in turn, has a base covariance, that &lt;em&gt;it&lt;/em&gt; inherits, all the way to the root, whose base covariance is the &quot;position variance&quot; parameter.  Thus, the leaves have a base covariance that is the sum of all the incremental variance of all the branches to the root.&lt;/p&gt;

&lt;p&gt;The base covariance is an NxN matrix, where N is the number of views.  We construct each in isolation, and then cumulatively sum them from root to leaf.&lt;/p&gt;

&lt;p&gt;Every element of the curve's observed-point covariance matrix is increased by the base_covariance relative to it's entry; e.g. if element (k_{ij}) is the covariance between a point in view 3 and a point in view 5, you'll add the (3,5) element of the base covariance matrix.&lt;/p&gt;

&lt;h2&gt;Base Parent covariance&lt;/h2&gt;

&lt;p&gt;Each child curve also hase a &quot;parent covariance&quot; (for lack of a better term), which is the set of covariances between the branch point and each of the parent points.  Again, this is inherited recursively; just as the curve's covariance has it's self-covariance added, the parent covariance has the paren'ts self-covariance added.&lt;/p&gt;

&lt;p&gt;This will be used for the off-diagonal blocks of the full attachment covariance matrix.&lt;/p&gt;

&lt;h2&gt;Implementation Misc&lt;/h2&gt;

&lt;p&gt;Issues during implementation and testing of &lt;code&gt;construct_attachment_covariance&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;replacing Cell-of-structs with struct-array:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Corrs = cell2mat(Corrs);
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;The trivial code path of calling &lt;code&gt;blkdiag&lt;/code&gt; takes 500ms. Wow!&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Running on the WACV dataset is giving bad results.&lt;/p&gt;

&lt;p&gt;Looks like the covariance matrix is different from the one in the reference implementation.&lt;/p&gt;

&lt;p&gt;TODO:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Need to convert from &quot;index of branch index&quot; to simply &quot;branch index&quot;.&lt;/li&gt;
&lt;li&gt;More debugging.&lt;/li&gt;
&lt;/ul&gt;

</description>
				<pubDate>Thu, 12 Sep 2013 00:00:00 -0700</pubDate>
				<link>http://vision.sista.arizona.edu/ksimek/research/2013/09/12/work-log</link>
				<guid isPermaLink="true">http://vision.sista.arizona.edu/ksimek/research/2013/09/12/work-log</guid>
			</item>
		
			<item>
				<title>Branching prior covariance</title>
				<description>

&lt;div class=&quot;meta-info&quot;&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;Project&lt;/th&gt;
        &lt;td&gt;&lt;a href=&quot;/ksimek/research/projects/tulips.html&quot;&gt;Tulips&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Subproject&lt;/th&gt;
        &lt;td&gt;Data Association v3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Working path&lt;/th&gt;
        &lt;td&gt;projects/&amp;#8203;tulips/&amp;#8203;trunk/&amp;#8203;src/&amp;#8203;matlab/&amp;#8203;data_association_3&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
        &lt;th&gt;SVN Revision&lt;/th&gt;
        &lt;td&gt;15229&lt;/td&gt;
    &lt;/tr&gt;


&lt;/table&gt;

    Unless otherwise noted, all filesystem paths are relative to the &quot;Working path&quot; named above.
&lt;/div&gt;


&lt;p&gt;In the past, we've formulated the branching prior covariance matrix by starting with an independent-curve block-diagonal covariance matrix and multiplying by an &quot;attachment matrix.&quot;  This works when the branching point appears in the index set, but we'd like to allow branching from any continuous point along the curve.  Stated differently, we currently model branching using a discritized model, but we'd prefer to express branching using the underlying continuous gaussian process.  This means modelling branching using the covariance function, rather than by manipulating the covariance matrix.&lt;/p&gt;

&lt;div&gt;
&lt;p&gt;
The key observation here is that in addition to each point's smooth curvature variance, it inherits the covariance of its parent's branch point.   In order to model correlation between curves, we extend the definition of &quot;index&quot; to add the curve index, \(c_i\), in addition to point index and time/view index.  Thus, index is now a triple: (c_i, p_i, t_i).  Note that we've changed our notation; previously point index was \(t_i\) and time/view index was \(v_i\).  The new notation uses \(p_i\) and \(t_i\) respectively, to avoid confusion between spacial and temporal dimensions.  
&lt;/p&gt;

&lt;p&gt;
Let's introduce two functions, \(\text{branch_curve}(c_i)\) and \(\text{branch_point}(c_i)\), which return the curve index and point index of curve \(c_i\)'s branch point, resepectively, or zero if \(c_i\) is a root curve.  We'll also use the convenience function \(\text{branch}(i)\), which is shorthand for full branch index, i.e. the tuple \(\text{branch_curve}(c_i), \text{branch_point}(p_i), t_i)\).  Note that the time-index \(t_i\) is preserved when getting the branch index.
&lt;/p&gt;

&lt;p&gt;
Without loss of generality, we'll assume curves are indexed in topological order, with parents appearing occurring before descendants.  If there are multiple connected components in the graph, it will be important that all root nodes have a lower index than non-root nodes, so we can add a sentinal node with index \(c_i = 0\), and attach all root curves to it before ordering. (Note to self: breadth-first search order might be simpler to describe).   The branching covariance function is now:
&lt;/p&gt;

\[
\begin{align}
k\left( i, j \right) 
     &amp;= 
    k\left( (c_i, p_i, t_i), (c_j, p_j, t_j) \right)  \\
     &amp;=  
     \begin{cases}
     k(j, i) &amp; \text{if } c_i &gt; c_j = 0 \\
     k_\text{base} ( i, j ) + k_o(ti, tj)  &amp; \text{if } \text{isroot}(c_i) \text{ and } \text{isroot}(c_j) \text{ and } c_i = c_j &amp;&amp;  \\
     k_\text{base} ( i, j ) + 0 &amp; \text{if } \text{isroot}(c_i) \text{ and } \text{isroot}(c_j) \text{ and } c_i \neq c_j \\
     k_\text{base} ( i, j ) + k(i, \text{branch}(j)) &amp; \text{otherwise} 
    \end{cases}
\end{align}
\]



&lt;p&gt;
For convenience, we've used the \(k(i,j) \) to stand-in for \(k\left((c_i, p_i, t_i), (c_j, p_j, t_j)\right)\).
  Here, \(k_\text{base}(i,j)\) is the independent curve covariance (e.g. cubic spline covariance w/ perturbations).   In our case, \(k_\text{base}(\dot)\) is zero if \(c_i \neq c_j\), but this isn't necessarilly required.
  &lt;/p&gt;

&lt;p&gt;
Here, \(k_o\) is to marginal covariance of the first curve point.  All points in the plant are measured relative to this point, so this covariance ends up in every element of the covariance matrix.  Since it only measures covariance of a specific point with respect to itself, curve and point index are irrelevant to \(k_o\).  Only the temporal is received, which allows us to model how the point moves over time.

In the case of the Ornstein Uhlenbech process, \(k_o\) is

\[
k_o = \sigma_o + \exp(|t_i - t_j|) \sigma_{o,b})
\]
&lt;/p&gt;

&lt;/div&gt;


&lt;p&gt;Lets examine each case in the piecewise function.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The first case just simplifies the definition by ensuring that if i and j are related, the ancestor always appears in the first position.&lt;/li&gt;
&lt;li&gt;The second case handles the offset variance that allow root curves to translate away from the origin.&lt;/li&gt;
&lt;li&gt;The third case ensures zero covariance between disconnected trees.&lt;/li&gt;
&lt;li&gt;The fourth case inherits covariance from the second parameter's parent curve.  Note that \(c_j\) is always a non-root curve; if it were, one of the first three cases would handle it.&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Testing &lt;/h2&gt;

&lt;h2&gt;TODO&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Finish tracing wacv datasets 7 through 11.&lt;/li&gt;
&lt;li&gt;Test the new covariance function against a matrix-based approach.&lt;/li&gt;
&lt;li&gt;Test the new covariance function by reconstructing 9-view sequence using WACV datasets.&lt;/li&gt;
&lt;li&gt;implement attachment-based ml using new covariance function&lt;/li&gt;
&lt;/ul&gt;

</description>
				<pubDate>Tue, 10 Sep 2013 00:00:00 -0700</pubDate>
				<link>http://vision.sista.arizona.edu/ksimek/research/2013/09/10/work-log</link>
				<guid isPermaLink="true">http://vision.sista.arizona.edu/ksimek/research/2013/09/10/work-log</guid>
			</item>
		
			<item>
				<title>WACV results</title>
				<description>

&lt;div class=&quot;meta-info&quot;&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;Project&lt;/th&gt;
        &lt;td&gt;&lt;a href=&quot;/ksimek/research/projects/tulips.html&quot;&gt;Tulips&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Subproject&lt;/th&gt;
        &lt;td&gt;Data Association v3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Working path&lt;/th&gt;
        &lt;td&gt;projects/&amp;#8203;tulips/&amp;#8203;trunk/&amp;#8203;src/&amp;#8203;matlab/&amp;#8203;data_association_3&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
        &lt;th&gt;SVN Revision&lt;/th&gt;
        &lt;td&gt;15229&lt;/td&gt;
    &lt;/tr&gt;


&lt;/table&gt;

    Unless otherwise noted, all filesystem paths are relative to the &quot;Working path&quot; named above.
&lt;/div&gt;


&lt;p&gt;WACV deadline has passed, but still working on reconstructing ground truth, because it's  a good test on the end-to-end system.&lt;/p&gt;

&lt;p&gt;Open issues:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;weird issue with branching&lt;/li&gt;
&lt;li&gt;clear up math issue with branching&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Branching bug&lt;/h1&gt;

&lt;p&gt;Fixed!  It was a bug in &lt;code&gt;infer_branch_points()&lt;/code&gt; function.  I was assuming Corr.curve_sm used the same  index set as Corr.ll_means_flat, which it was not.&lt;/p&gt;

&lt;p&gt;I wanted to use &lt;code&gt;Corr.curve_sm&lt;/code&gt;, because it is precomputed in &lt;code&gt;corr_to_likelihood()&lt;/code&gt;, and it would save me an extra semi-expensive call to the cubic spline smoother, &lt;code&gt;csaps()&lt;/code&gt;.  In the end, I modified &lt;code&gt;corr_to_likelihood&lt;/code&gt; to save the smoothing amount and used it to call csaps inside &lt;code&gt;run_wacv()&lt;/code&gt; to re-smooth the curves.  At least &lt;code&gt;csaps&lt;/code&gt; is faster (linear time) than computing the posterior mean (quadratic).&lt;/p&gt;

&lt;h2&gt;Test Results&lt;/h2&gt;

&lt;p&gt;Results on dataset 2:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ksimek/research/img/2013-09-06-result_dataset_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Looks good!&lt;/p&gt;

&lt;h2&gt;All Results&lt;/h2&gt;

&lt;p&gt;Running on all 11 datasets...&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Matlab is running out of memory on the second dataset (apparently)&lt;/p&gt;

&lt;p&gt;When running directly on second dataset, it's fine.  Is the pass on the first dataset leaking memory or something?&lt;/p&gt;

&lt;p&gt;Maybe one of the mex files?&lt;/p&gt;

&lt;p&gt;It's weird, because we've run on dataset #2 tens of times without this problem...&lt;/p&gt;

&lt;p&gt;Now running directly on dataset #2 is resulting in a curve of over 1 million points.  investigating...&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Solution: the image dimensions were reversed (should be nrows X ncols, not width x height).  The triangulations were nutso, and after projecting and resampling, the number of points was in the millions.  It's interesting that it's so easy to make this algorithm blow up; are there other; will need to keep an eye out for more benign ways to trigger this kind of explosion.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;Ground truth issues&lt;/h2&gt;

&lt;p&gt;Encountered this error message when running on all ground truth datasets:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Warning: file wacv-2012/datasets/3/ground_truth_2d.gt2
Missing curves in view 6: 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15, 16,

Warning: file wacv-2012/datasets/6/ground_truth_2d.gt2
Missing curves in view 2: 2, 3,

Warning: file wacv-2012/datasets/6/ground_truth_2d.gt2
Missing curves in view 3: 3,

Warning: file wacv-2012/datasets/6/ground_truth_2d.gt2
Missing curves in view 4: 2, 3,

Warning: file wacv-2012/datasets/6/ground_truth_2d.gt2
Missing curves in view 6: 2, 3,

Warning: file wacv-2012/datasets/6/ground_truth_2d.gt2
Missing curves in view 8: 1, 3,

Warning: file wacv-2012/datasets/6/ground_truth_2d.gt2
Missing curves in view 10: 3,

Warning: file wacv-2012/datasets/6/ground_truth_2d.gt2
Missing curves in view 15: 3,

Warning: file wacv-2012/datasets/6/ground_truth_2d.gt2
Missing curves in view 19: 3,

Warning: file wacv-2012/datasets/6/ground_truth_2d.gt2
Missing curves in view 23: 2, 3,

Warning: file wacv-2012/datasets/6/ground_truth_2d.gt2
Missing curves in view 27: 3,

Warning: file wacv-2012/datasets/6/ground_truth_2d.gt2
Missing curves in view 31: 3,

Warning: file wacv-2012/datasets/6/ground_truth_2d.gt2
Missing curves in view 35: 3,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dataset 6 looks to be totally crap; need to investigate.&lt;/p&gt;

&lt;h2&gt;Found a bug in &lt;code&gt;corr_to_likelihood&lt;/code&gt; that led to out-of-bound indexing.&lt;/h2&gt;

&lt;p&gt;Looks like Liu never finished ground-truthing dataset &lt;code&gt;2010-01-26/arab_1_36&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Skipping for now; lets see if others are okay...&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Dataset 9 is broken. investigating...&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Dataset 9 seems not terrible, actually.  A few missing views on the hard-to-trace views of a few curves.&lt;/p&gt;

&lt;p&gt;Some cuves were so short that they contained only one point, which violated an assert that requires all curves to be at least 2 points long.  Adjusted the bezier-to-sampled-curve code so that the final point is always included.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Finished running all.  issues&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;dataset 1 is very rough&lt;/li&gt;
&lt;li&gt;datasets 6 was skipped&lt;/li&gt;
&lt;li&gt;datasets 7 - 11 are worthless.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Need to re-trace 6 through 11.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Finished re-trace of 6.  Whew, 90 minutes... that sucked.  Reconstruction looks good now.&lt;/p&gt;

&lt;h2&gt;TODO&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Finish tracing datasets 7 through 11.&lt;/li&gt;
&lt;li&gt;Work on attached-curve-multi-view prior and reconstruction.&lt;/li&gt;
&lt;/ul&gt;

</description>
				<pubDate>Fri, 06 Sep 2013 00:00:00 -0700</pubDate>
				<link>http://vision.sista.arizona.edu/ksimek/research/2013/09/06/work-log</link>
				<guid isPermaLink="true">http://vision.sista.arizona.edu/ksimek/research/2013/09/06/work-log</guid>
			</item>
		
			<item>
				<title>WACV Deadline</title>
				<description>&lt;p&gt;Late-hour realization: not sure how to handle attachment matrix when multiple-views are allowed.  Deriving the correct equations will take all afternoon; no time.  Decided to remove the tracking part from the paper.&lt;/p&gt;

&lt;h1&gt;Reconstructions&lt;/h1&gt;

&lt;p&gt;code in &lt;code&gt;wacv-2012/run_wacv.m&lt;/code&gt;.  Example call:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gt_paths = arrayfun(@(x) sprintf('wacv-2012/datasets/%d', x), 1:11, 'UniformOutput', false);
gt_cam_fmt = [gt_paths{i} '/cal/calib_%d.txt'];
gt_fname = [gt_paths{i} '/ground_truth_2d.gt2'];
[mu, lengths] = run_wacv(gt_fname, gt_cam_fmt, 1:4:36, [397,530]', params, 1);
mu = reshape(mu, 3, []);
mu = mat2cell(mu, 3, lengths);
colors = lines(numel(mu));
for i = 1:numel(mu);
    c = mu{i};
    col = colors(i, :);
    plot3(c(1,:), c(2,:), c(3,:), '-o', 'Color', col);
    hold on
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Results&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Dataset #1&lt;/em&gt;: curve #1 has some weird shape.  Probably and error in GT&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Dataset #2&lt;/em&gt;: again weirdness in curve #1.  Now I'm guessing it's an attachment issue:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ksimek/research/img/2013-09-05-bad_result_c2_pass1.png&quot; alt=&quot;bad result&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Run again without attachments.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Dataset #2&lt;/em&gt;: curve 1 issue is better; now exhibiting some weird stray points.  few views, bad indices?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ksimek/research/img/2013-09-05-c2-pass2.png&quot; alt=&quot;result 2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;It looks like the base curves are trying to attach to the &lt;em&gt;end&lt;/em&gt; of curve #1, instead of the beginning.&lt;/p&gt;
</description>
				<pubDate>Thu, 05 Sep 2013 00:00:00 -0700</pubDate>
				<link>http://vision.sista.arizona.edu/ksimek/research/2013/09/05/work-log</link>
				<guid isPermaLink="true">http://vision.sista.arizona.edu/ksimek/research/2013/09/05/work-log</guid>
			</item>
		
	</channel>
</rss>
